# linux
netdev_sent_queue() 用于更新已发送的数据包的数据结构的函数，它有三个参数，分别是网络设备指针，已发送的数据包个数和已发送的字节数。它的作用是将网络设备的sent_queue数据结构中的已发送的数据包个数和字节数增加相应的值，以便内核可以在合适的时机释放已发送的数据包占用的内存，例如在收到网卡的传输完成中断时。

netdev_completed_queue() 用于更新已完成的I/O请求的数据结构的函数，它有三个参数，分别是网络设备指针，已完成的请求个数和已完成的字节数。它的作用是将网络设备的completed_queue数据结构中的已完成的请求个数和字节数增加相应的值，以便内核可以在合适的时机处理已完成的请求，例如释放资源、通知用户空间等。

skb.eth_type_trans() skb.protocol_set() skb的protocol字段在数据包从链路层向上传递时，会被用于判断数据包的网络层协议，并调用相应的处理函数。在网卡驱动中，收到数据包后，会调用eth_type_trans函数，该函数会根据以太网帧头中的协议类型，调用skb protocol_set函数设置skb的protocol字段，然后将skb传递给netif_receive_skb函数，该函数会根据skb的protocol字段，调用相应的网络层处理函数，如ip_rcv、ipv6_rcv等。

# NAPI
NAPI是一种提高网络处理效率的技术，它的核心思想是在高流量负载下，不使用中断的方式读取数据，而是使用轮询的方式来检查设备是否有数据包到达。

napi_complete_done() 用于通知内核NAPI设备轮询完成的函数，表示轮询处理的数据包个数。它的作用是将NAPI结构体从轮询列表中删除，并清除其状态的NAPI_STATE_SCHED位，表示不需要再被调度。它还会根据返回值判断是否需要重新开启设备的中断，以便接收新的数据包。

napi_schedule() 用于调度一个NAPI设备的轮询，驱动程序应该在收到中断时调用这个函数。一个成功的调用会获取NAPI设备的所有权，然后在合适的时机调用它的poll函数来处理数据包。

add_weight() weight表示每次调用NAPI的poll函数时，最多可以处理的数据包个数。通常这个值是64.

NAPI的工作流程大致如下：

1.当设备收到数据包时，产生一个硬件中断，通知内核。

2.内核调用中断处理函数，关闭设备的中断，将NAPI结构体加入到轮询列表中，触发软中断。

3.软中断调用net_rx_action函数，从轮询列表中取出NAPI结构体，调用其poll函数，处理数据包。

4.poll函数每处理一个数据包，就调用napi_consume(64)来更新napi_gro_count字段，如果napi_gro_count为0，或者没有更多的GRO数据包可处理，就退出轮询模式，重新开启设备的中断，等待下一次硬件中断。poll函数返回驱动程序本次处理的数据包个数。用来判断是否达到了NAPI_POLL_WEIGHT上限。

(napi_gro_count是NAPI结构体中的一个字段，它表示当前NAPI设备正在处理的GRO数据包的个数。GRO是一种通用的接收聚合技术，它的作用是将多个相同流的数据包合并成一个大的数据包，从而减少内核协议栈的处理开销。napi_gro_count的值会在每次调用napi_consume函数时减去处理的数据包个数，如果结果为0，就表示NAPI已经处理完所有的GRO数据包，可以退出轮询模式。) 

# FOO
以太网帧的结构，它由以下几个部分组成：
- 前导码（Preamble）：7个字节，用于同步发送端和接收端的时钟信号。
- 起始定界符（Start of Frame Delimiter，SFD）：1个字节，用于标识帧的开始。
- 目的地址（Destination Address，DA）：6个字节，用于指定接收端的MAC地址。
- 源地址（Source Address，SA）：6个字节，用于指定发送端的MAC地址。
- 类型/长度（Type/Length）：2个字节，用于指定帧的类型或长度。
- 数据（Data）：46~1500个字节，用于存储帧的有效载荷，包括其他协议的报头和数据。
- 帧检验序列（Frame Check Sequence，FCS）：4个字节，用于存储CRC校验码，用于检测帧在传输过程中是否出现错误。

fujita rust-e1000中length -= 4的操作是为了去掉FCS。